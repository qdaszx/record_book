### 아이템8 타입 공간과 값 공간의 심벌 구분하기

- **요약**
  - 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야 합니다. 타입스크립트 플레이그라운드를 활용해 개념을 잡는 것이 좋습니다.
  - 모든 값은 타입을 가지지만, 타입은 값을 가지지 않습니다. type과 interface 같은 키워드는 타입 공간에만 존재합니다.
  - class나 enum 같은 키워드는 타윕과 값 두 가지로 사용될 수 있습니다.
  - "foo"는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있습니다. 차이점을 알고 구별하는 방법을 터득해야 합니다.
  - typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있습니다.

<br>

### 아이템9 타입 단언보다는 타입 선언을 사용하기

- **요약**
  - 타입 단언(as Type)보다 타입 선언(: Type)을 사용해야 합니다.
  - 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 합니다.
  - 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 null 아님 단언문을 사용하면 됩니다.

<br>

### 아이템10 객체 래퍼 타입 피하기

- **요약**
  - 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 합니다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 합니다.
  - 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 합니다. String 대신 string, Number 대신 number, Boolean 대신 boolean, Symbol 대신 symbol, BigInt 대신 bigint를 사용해야 합니다.

<br>

### 아이템11 잉여 속성 체크의 한계 인지하기

- **요약**
  - 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행됩니다.
  - 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다릅니다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있습니다.
  - 잉여 속성 체크에는 한계가 있습니다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다는 점을 기억해야 합니다.

<br>

### 아이템12 함수 표현식에 타입 적용하기

- **요약**
  - 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋습니다.
  - 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 합니다. 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 합니다.
  - 다른 함수의 시그니처를 참조하려면 `typeof fn`을 사용하면 됩니다.

<br>

### 아이템13 타입과 인터페이스의 차이점 알기

- **요약**
  - 타입과 인터페이스의 차이점과 비슷한 점을 이해해야 합니다.
  - 한 타입을 type과 interface 두 가지 문법을 사용해서 작성하는 방법을 터득해야 합니다.
  - 프로젝트에서 어떤 문법을 사용할지 결정할 때 한 가지 일관된 스타일을 화립하고, 보강 기법이 필요한지 고려해야 합니다.

<br>

### 아이템14 타입 연산과 제네릭 사용으로 반복 줄이기

- **요약**
  - DRY(don't repeat yourself) 원칙을 타입에도 최대한 적용해야 합니다.
  - 타입에 이름을 붙여서 반복을 피해야 합니다. extends를 사용해서 인터페이스 필드의 반복을 피해야 합니다.
  - 타입들 간의 매핑을 위해 타입스크립트가 제공한 도구들을 공부하면 좋습니다. 여기에는 keyof, typeof, 인덱싱, 매핑된 타입들이 포함됩니다.
  - 제너릭 타입은 타입을 위한 함수와 같습니다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑하는 것이 좋습니다. 제너릭 타입을 제한하려면 extends를 사용하면 됩니다.
  - 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 합니다.

<br>

### 아이템15 동적 데이터에 인덱스 시그니처 사용하기

- **요약**
  - 런타임 때까지 객체의 속성을 알 수 없을 경우에만(예를 들어 CSV 파일에서 로드하는 경우) 인덱스 시그니처를 사용하도록 합니다.
  - 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 합니다.
  - 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋습니다.

<br>

### 아이템16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

- **요약**
  - 배열은 객체이므로 키는 숫자가 아니라 문자열입니다. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드입니다.
  - 인덱스 시그니처에 number를 사용하기보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋습니다.

<br>

### 아이템17 변경 관련된 오류 방지를 위해 readonly 사용하기

- **요약**
  - 만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋습니다. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지합니다.
  - readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있습니다.
  - const와 readonly의 차이를 이해해야 합니다.
  - readonly는 얕게 동작한다는 것을 명심해야 합니다.
