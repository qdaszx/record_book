## 컴퓨터 내부의 언어 체계

컴퓨터는 어떤 말을 사용할까

<br>

### 언어란 무엇인가

- 언어는 편의를 제공하기 위한 지름길
- 언어를 사용하면 복잡한 개념을 직접 보여주지 않고도 의사소통을 할 수 있다.
- 모든 언어의 뜻은 기호의 집합으로 **인코딩(encoding)** 된다.
- 언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 **문맥(context)** 을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 한다.

<br>

### 문자 언어

- 문자 언어는 기호를 나열한 것이다.
- 세 가지 구성요소가 문자 언어의 틀을 이룬다
  - 기호가 들어갈 상자
  - 상자에 들어갈 기호
  - 상자의 순서

<br>

### 비트

- 자연어에서는 이 상자를 **문자(character)** 라고 부르고 컴퓨터에서는 **비트(bit)** 라고 부른다. '비트'라는 단어는 2진법을 사용한다는 '바이너리(binary)'와 숫자를 뜻하는 '디지트(digit)'가 기묘하게 합쳐진 말이다.
- 비트는 2진법을 사용한다. 이는 비트 상자에는 모스 부호의 점(.)과 선(-)처럼 두 가지 기호 중 하나만 담을 수 있다는 뜻이다.
- 기호라는 개념은 추상적이다. 하지만 언어는 문맥 없이는 제대로 작동할 수 없다는 것을 기억하라.

<br>

### 논리 연산

- 비트 사용법 중 하나는 "날씨가 추운가?", "내 모자를 좋아하나?"와 같은 예/아니오 질문에 대한 답을 표현하는 것이다.
- '예'를 **참(true)**, '아니요'를 **거짓(false)** 라는 용어로 부른다
- 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 **논리 연산(logic operation)** 이라고 한다.

<br>

- **불리언 대수**

  - NOT, AND, OR, XOR

<br>

- **드모르간의 법칙**
  - 이 법칙은 `a AND b 라는 연산은 NOT(NOT a OR NOT b)` 와 같다고 말한다.
  - NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신할 수 있다(그리고 역으로 OR을 AND로 대신할 수 있다)는 뜻이다.
  - **긍정적인 논리(positive logic)** 에 더해 **부정적인 논리(negative logic)** 를 기술하는 명제를 사용할 때 드모르간의 법칙을 활용할 수 있다.

<br>

### 정수를 비트로 표현하는 방법

- **양의 정수 표현**

  - **가장 작은 유효 비트(least significant bit)** = `LSB`
  - **가장 큰 유효 비트(most significant bit)** = `MSB`

<br>

- **2진수 덧셈**

  - 덧셈 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면 어떻게 해야 할까? 이런 경우 **오버플로(overflow)** 가 발생한다. 오버플로란 말은 MSB에서 올림이 발생했다는 뜻이다.
  - MSB 위쪽에서 1을 빌려오는 경우를 **언더플로(underflow)** 라고 부른다.

<br>

- **음수 표현**

  - 4비트로 수를 16가지만 표현할 수 있다는 말이 꼭 4비트로는 0부터 15까지만 표현할 수 있다는 뜻은 아니다. 기억하라. 언어는 문맥과 의미를 통해 작용한다. 이 말은 비트들을 해석하는 새로운 문맥을 만들 수 있다는 뜻이기도 한다.

- 부호와 크기 표현법

  - 음수와 양수를 구별하기 위해 흔히 부호(sign)를 사용한다.
  - 양부호(+), 음부호(-) 라는 값이 있다.
  - 부호 비트가 0이면 이 2진수를 양수로 취급하고 부호 비트가 1이면 이 2진수를 음수로 취급하자.
  - 0부터의 거리(절댓값)를 표현하기 위해 사용하는 이런 방법을 **부호와 크기(sign and magnitude)** 표현법이라고 한다.
  - 부호와 크기 표현법은 두 가지 이유로 인해 널리 쓰이지 못하고 있다. 0을 표현하는 방법이 두 가지라서 비용이 낭비, XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다.

- 1의 보수

  - 양수의 모든 비트를 뒤집는 방법이 있다. 이런 방법은 **1의 보수(one's complement) 표현법** 이라고 부른다.
  - MSB 쪽에서 올림이 발생한 경우에는 LSB로 올림을 전달해야 하는데, 이를 **순환 올림(end-around carry)** 이라고 부른다.
  - 현대 컴퓨터에서는 부호와 크기 표현법이나 1의 보수 표현법을 모두 사용하지 않는다. 추가적인 하드웨어 없이는 제대로 작동할 수 없고, 하드웨어를 추가해야 한다는 말은 비용이 더 든다는 뜻이다.

- 2의 보수
  - 4비트 수의 경우 +1은 0001이다. 그럼 1111을 0001에 더하면 0000이 된다. 따라서 앞으로 1111을 (4비트에서) -1을 표현하는 비트 패턴으로 사용하자.
  - 이런 표현법을 **2의 보수(two's complement) 표현법** 이라고 하며, 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법이다.
  - 2의 보수에서 0의 중복 표현 문제가 없는 0을 가지고 살펴보자
  - 0000의 모든 비트를 뒤집으면 1111을 얻는다. 1111에 1을 더하면 [1]0000이 되는데 이 숫자는 5비트이므로 우리가 사용할 수 있는 4비트보다 크다. 따라서 1을 올림 비트로 생각하고 무시한다. 결과는 0000인데 이 값은 처음에 시작한 0과 같다. 따라서 2의 보수 표현법에서는 0을 표현하는 방법의 하나뿐이다.
  - 우리가 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다는 점을 꼭 염두에 둬야 한다.

### 실수를 표현하는 방법

- 고정소수점 표현법
  - 2진 소수점의 위치를 임의로 정하는 방법
  - 소수점의 위치가 항상 일정하기 때문에 이런 방식을 **고정소수점(fixed-point)** 표현법이라고 부른다.
  - 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서는 이런 방식을 사용하는 경우는 드물다.
  - 범용 컴퓨터는 일반적인 문제를 해결하기 위해 만들어진 컴퓨터라서 그렇게 불린다.
  - **플랑크 상수(Planck's constant)** (양자 역학 기본 상수 중 하나)
  - **아보가드로 수(Avogadro's constant)**

<br/>

- 부동소수점 표현법
  - **과학적 표기법(scientific notation)** 을 2진수에 적용한다.
  - 과학적 표기법에서는 10진 소수점 왼쪽이 한 자리뿐인 소수(이를 **가수(mantissa)** 라고 한다)에 10을 몇 번(이를 **지수(exponent)** 라고 한다) 거듭제곱한 값을 곱하는 방식으로 소수를 표현한다.
  - 이러한 표현법을 **부동소수점(floating-point) 표현법** 이라고 부른다.
  - 부동소수점 표현법은 지수와 가수를 분리함으로써 수를 표현할 때 필요한 (소수점 왼쪽에서 연속으로 나타나거나 소수점 오른쪽에 연속으로 나타나는) 0을 모두 저장하지 않고도 큰 수나 작은 수를 표현할 수 있다.

<br/>

- IEEE 부동소수점 수 표준
  - 부동소수점 수 시스템은 컴퓨터에서 계산을 수행할 때 실수를 표현하는 표준 방법이다.
  - 똑같은 비트를 사용하더라도 정밀도(precision)를 가능하 한 높이고 싶다.
  - 한 가지 트릭은 **정규화(nomalization)**
  - 정규화는 가수를 조정해서 맨 앞(즉, 왼쪽)에 0이 없게 만드는 것
  - 두 번째 트릭은 디지털 이큅먼트 사(DEC, Digital Equipment Corporation)에서 고안한 것으로, 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략하는 것
  - 두 가지 부동소수점 수가 자주 쓰인다는 사실을 알아둬야 한다.
  - 한 가지는 **기본 정밀도(single precision)** 부동소수점 수
  - 다른 한 가지는 **2배 정밀도(double precision)** 부동소수점 수
  - 2배 정밀도 수가 기본 정밀도 수보다 지수가 3비트 더 크다
  - 지수의 범위는 8배 더 크다
  - 2배 정밀도 수는 기본 정밀도 수보다 가수가 29비트 더 크다.
    정밀도도 훨씬 더 크다
  - 하지만 모든 장점은 비트를 2배나 더 많이 사용한다는 비용을 지불하고 얻은 것
  - 지수 비트가 모두 0이거나 1인 경우에 특별한 의미를 갖게 하고, 실제 자숫값은 나머지 비트 패턴에 집어넣고 싶었다.
  - IEEE 754 설계자들은 **편향된(biased)** 지숫값을 사용해 이를 달성할 수 있었다.
  - IEEE 754에서 편리한 점은 0으로 나눴을 때 생길 수 있는 양의 무한대나 음의 무한대를 표현하는 비트 패턴 등 여러 가지 특별한 비트 패턴을 제공한다는 점이다.

<br/>

### 2진 코드화한 10진수 시스템

- **2진 코드화한 10진수(BCD, binary-coded decimal)**
- BCD는 4비트를 사용해 10진 숫자를 하나 표현한다.
- BCD 시스템의 인기가 줄어든 이유는 BCD가 2진수를 효율적으로 활용하지 못하기 때문
- BCD가 일반적인 2진수에 비해 같은 수를 표현할 때 더 많은 비트를 사용한다는 점

<br/>

### 2진수를 다루는 쉬운 방법

- 8진 표현법
  - **8진 표현법(octal representation)** 은 2진수 비트들을 3개씩 그룹으로 묶는 아이디어

<br/>

- 16진 표현법
  - **16진 표현법(hexadecimal representation)** 은 컴퓨터 내부가 8비트의 배수를 사용해 만들어지기 때문에 8진 표현법보다 많이 쓰인다.

<br/>

- 프로그래밍 언어의 진법 표기법
  - 0으로 시작하는 숫자는 8진 숫자다. 예를 들어, 017은 8진수이며 값은 10진수로 15다.
  - 1부터 9 사이의 숫자로 시작하는 숫자는 10진수다. 예를 들어, 123은 10진수다.
  - 0x가 앞에 붙은(접두사) 숫자는 16진수다. 예를 들어, 0x12f는 16진수이며 값은 10진수 303이다.

<br/>

### 비트 그룹의 이름

- 컴퓨터를 설계하는 사람은 비용을 고려해 컴퓨터가 사용할 비트의 개수와 비트들의 조직을 결정해야만 한다.
- 세계적으로 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 **바이트(byte)** 라고 부른다.

  - 니블(nibble) 4비트
  - 바이트(byte) 8비트
  - 하프 워드(half word) 16비트
  - 워드(word) 32비트
  - 더블 워드(double word) 64비트

- **워드(word)** 는 각 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기를 가리키는 말로 쓰인다.
- 컴퓨터가 빠르게 처리할 수 있는 가장 큰 덩어리를 뜻한다.
- **킬로비트(kilobit)** 나 **킬로바이트(kilobyte)** 에서 킬로는 실제로는 1000을 뜻하지 않고, 밑이 2이면서 1000에 가장 가까운 수인 1024, 즉 2^10을 뜻했다. 비슷하게 **메가바이트(megabyte)** (M 또는 MB)의 메가는 2^20, **기가바이트(gigabyte)** (G 또는 GB)의 기가는 2^30, **테라바이트(terabyte)** (T 또는 TB)의 테라는 2^40 이었다.
- 전통적으로 디스크 크기를 다룰 때는 밑을 10으로 사용했다.
- 새로운 IEC 표준 접두사가 만들어졌다. **키비(kibi)KiB** 는 2^10, **메비(mebi)MiB** 는 2^20, **기비(gibi)GiB** 는 2^30, **테비(tebi)TiB** 는 2^40을 뜻한다.

<br/>

### 텍스트 표현

- 아스키 코드
  - 텍스트를 표현하는 방법의 경우에도 몇 가지 아이디어가 서로 경쟁
  - 승자는 정보 교환을 위한 **미국 표준 코드(ASCII, American Standard Code for Information interchange)** 였다('아스키'라고 읽는다).
  - 아스키는 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당했다.
  - 패자는 IBM의 **확장 BCD 교환 코드(EBCDIC, Extended Binary-Coded Decimal Interchange Code)** 가 있다('엡시딕'이라고 읽는다).
  - 이 코드는 펀치 카드에 사용한 인코딩을 기반으로 만들어진 코드
  - 아스키 코드에 글자를 출력하는 데 쓰이지 않고 장치를 제어하기 위해 쓰이기 때문에 **제어 문자(control character)** 라고 불린다.

<br/>

- 다른 표준의 진화
  - 컴퓨터가 널리 쓰이게 됨에 따라 그 밖에 언어를 지원해야 할 필요가 점차 늘어났다.
  - **국제 표준화 기구(ISO, International Standards Organization)** 는 ISO-646과 ISO-8859를 도입했다.
  - **일본 산언 표준(JIS, Japanese Industrial Standards)** 위원회는 일본 문자를 표현하기 위해 JISX 0201을 만들었다.
  - 중국어, 아랍어, 한국어(KS C 5601) 등의 표준도 생겼다.
  - 비트 가격이 떨어짐에 따라 **유니코드(Unicode)** 라는 새로운 표준이 만들어졌고, 문자에 16비트 코드를 부여했다.
  - 유니코드는 21비트(그중 1,112,064가지 값이 문자를 표현한다)까지 확장됐으며, 그 정도면 앞으로 모든 문자를 다 표현할 수 있을 것이다.

<br/>

- 유니코드 변환 형식 8비트
  - 16비트를 사용해 낭비해도 될 만큼 비트가 저렴하지는 않다는 이유로 한 문자를 8비트로 표현한다.
  - 유니코드는 문자 코드에 따라 각기 다른 인코딩을 사용해 이런 문제를 해결한다.
  - **인코딩(encoding)** 은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴을 뜻한다.
  - 미국 컴퓨터과학자 켄 톰슨(Ken Thompson)과 캐나다 프로그래머 롭 파이크(Rob Pike)가 만든 **유니코드 변환 형식 8비트(UTF-8, Unicode Transformation Format-8 bit)** 라는 인코딩 방법이 하위 호환성과 효율성 때문에 가장 널리 쓰이고 있다.
  - UTF-8은 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때는 추가 공간이 필요하지 않다.
  - UTF-8은 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않은 방법으로 문자를 인코딩한다.
  - UTF-8은 문자를 8비트 덩어리(이를 옥텟(octet)이라고 부른다)의 시퀀스로 인코딩한다.
  - A 라는 문자의 숫자 코드가 아스키와 유니코드에서 같다는 사실을 알 수 있다.

<br/>

### 문자를 사용한 수 표현

- 출력 가능하게 변경한 인코딩
  - **출력 가능하게 변경한 인코딩(Quoted-Printable encoding)** 은 쿼티드 프린터블 인코딩, 혹은 QP 인코딩이라고도 하는데, 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 송수신하기 위한 인코딩 방법
  - QP 인코딩은 전자우편 첨부를 처리하기 위해 만들어졌다. 이 인코딩을 사용하면 = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트값을 표현한다.
  - 물론 이로 인해 =가 특별한 의미를 지니기 때문에 QP에서 =를 표현하려면 =3D를 사용해야 한다.
  - QP 인코딩은 몇 가지 추가 규칙을 사용한다.
  - 줄의 맨 끝에 탭과 공백 문자가 온다면, 이를 각각 =09와 =20으로 표현해야만 한다.
  - 인코딩된 데이터는 한 줄이 76자를 넘을 수 없다. 어떤 줄의 맨 뒤가 =로 끝나면 가짜 줄바꿈을 뜻하며, 수신 쪽에서 QP로 인코딩된 데이터를 디코딩할 때는 이 =를 제거하고 해석한다.

<br/>

- 베이스64 인코딩
  - QP 인코딩이 잘 작동하기는 하지만 1바이트를 표현하기 위해 3바이트를 사용하기 때문에 아주 비효율적이다.
  - **베이스64(base64)** 인코딩이 더 효율적
  - 베이스64 인코딩은 3바이트 데이터를 4문자로 표현한다.
  - 3바이트 데이터의 24비트를 네 가지 6비트 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현한다.

<br/>

- URL 인코딩
  - 웹 페이지 URL에서 %26이나 %2F 같은 문자 시퀀스를 본 적이 있을 것이다.
  - 이런 값이 있는 이유는 URL이라는 문맥에서 몇몇 문자가 특별한 의미를 지니기 때문이다. 하지만 이런 특별한 의미를 지니는 문자를 **리터럴(literal)** 로 사용할 필요가 있다('리터럴'이라는 말은 '문자 그대로'라는 뜻으로, 특별한 의미 없이 해당 문자 자체를 뜻하는 경우를 가리키는 영어 단어다).
  - 문자들은 8비트 덩어리의 시퀀스로 표현된다.
  - 각 덩어리는 2개의 16진 문자로 표현할 수 있다. **URL 인코등** 은 **퍼센트 인코딩(percent-encoding)** 이라고도 부르는데, % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다.

<br/>

### 색을 표현하는 방법

- 컴퓨터 그래픽스(graphics)는 전자 모눈종이에 해당하는 것에 색을 표현하는 점(blob)을 찍어서 그림을 만드는 과정이다.
- 이때 모눈의 각 격자에 찍는 점을 **그림 원소(picture element)** 라고 부르며, 줄여서 **픽셀(pixel)** 이라고 부른다.
- 컴퓨터 모니터는 빨간색, 녹색, 파란색 광선을 섞어서 색을 만들어내며, 이런 색 표현법을 **RGB색 모델(RGB color model)** 이라고 부른다.
- 색은 **컬러 큐브(color cube)** (정육면체) 라는 것으로 표현할 수 있다.
- 컬러 큐브에서 각 축은 **주(primary)** 색을 표현한다.
- 빛을 혼합해 색을 표현하는 방식을 **가산(additive)** 색 시스템이라고 부른다.
- 손으로 그림을 그린다면 아마도 **감산(subtractive)** 색 시스템에 더 익숙할 것이다.
- 감산 색 시스템에서는 주 색이 청록색(사이언), 자홍색(마젠타), 노란색(옐로)
- 가산 시스템(빛 혼합)이 감산 시스템(물감 혼합)보다 더 많은 색을 만들어낼 수 있다.
- 전체적인 빛의 세기에 맞춰 눈의 응답이 점차 변한다는 데 있다. 이를 암순응(dark adaptation)이라고 한다.
- 색을 표현할 때마다 사용하지 않는 비트가 8개 있다.
- 비트 낭비가 심하며 이 남은 비트로 **투명도(transparency)** 를 표현한다.
- 투명도라는 말은 해당 색을 '투과해 볼 수 있는 정도'를 뜻한다.

<br/>

- 투명도 추가
  - 1984년 영화 제작사 루카스필름의 톰 더프와 토머스 포터는 각 픽셀에 **알파(a)** 라는 투명도 값을 추가했다.
  - a는 수학적으로 0 이상 1 이하인 값이다.
  - 값이 완전히 투명하다는 뜻이고, 1은 완전히 불투명하다는 뜻이다.
  - 여러 다른 알파값의 색을 합성해 새로운 색을 만들어내는 방법을 정의하는 일련의 **합성 계산법(compositing algebra)** 식이 있다.

<br/>

- 색 인코딩
  - 웹에서는 색을 **16진 트리플렛(hex triplet)** 를 표현한다.
  - 16진 트리플렛은 # 뒤에 여섯 자리 16진 숫자를 추가해 #rrggbb 처럼 표현하는 방식이다.

<br/>

### 정리

- 1장에서는 개념적으로 단순한 비트를 사용해 아주 큰 숫자나 문자, 색 등의 복잡한 요소를 표현할 수 있다는 사실을 배웠다.
- 10진수를 2진수로 표현하는 방법
- 2진수를 사용해 간단한 사칙연산을 수행하는 방법
- 음수와 분수를 표현하는 방법
- 비트를 사용해 문자를 인코딩하는 여러 가지 표준에 대해 배웠다.
