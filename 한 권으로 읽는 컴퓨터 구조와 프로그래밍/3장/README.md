## 메모리와 디스크의 핵심: 순차 논리

_컴퓨터는 비트를 어떻게 기억하는가_

이번 장에서는 **순차 논리** 를 배운다.

순서는 '시간적으로 어떤 값 뒤에 오는 다른 값'이라는 뜻이다.

조합 논리는 입력의 현재 상태만을 다룬다.

하지만 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.

<br/>

### 시간 표현과 상태

컴퓨터의 경우 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요하다.

<br/>

- **발진자**

  **되먹임**(피드백)

  인버터 출력은 다시 인터버 입력으로 들어가며, 이 입력은 다시 출력에 반영된다.

  이로 인해 출력이 0과 1 사이를 **진동한다 oscillate** .

  정확한 발진자를 적은 비용으로 효율적으로 만드는 방법은 크리스털을 활용하는 것이다.

  자석과 마찬가지로 크리스털도 전기와 관련이 있다.

  **전극**(**electrode** 즉, 전선)을 크리스털에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어낸다.

  그리고 전극에 전기를 가하면 크리스털이 구부러진다.

  이런 현상을 **피에조 전기(piezoelectric)** (또는 **압전**) 효과라고 부른다.

  크리스털 발진자는 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어낸다.

  입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.

  <br/>

- **클록**

  가산기의 지연 시간을 기다릴 수 있다.

  발진자는 컴퓨터의 **클록**(**clock**) (시간을 셀 주 있게 해주는 신호)을 제공한다.

  클록은 회로의 페이스를 결정한다.

  **비닝**(**binning**) (바구니에 넣는다는 뜻) 과정은 부품을 측정해서 그 특정에 따라 여러 다른 빈이나 무더기로 분류한다.

  컴퓨터를 **오버클로킹**(**overclocking**) 한다는 말

  이 말은 통계적으로 빈의 중간 정도에 위치하는 부폼을 부품이 고장 나지 않을 범위 안에서 클록을 빠르게 공급하는 도박을 한다는 뜻이다.

  <br/>

- **래치**

  하드웨어 기호 위에 선을 그으면 **반전** 을 뜻한다.

  때로 이를 액티브 하이에 반대되는 **액티브 로우** 라고 부른다.

  이렇게 위에 그은 선을 '바' 라고 읽는다.

  **S-R래치** S-R이라는 말은 set-reset (설정-재설정)을 뜻한다.

  이들은 액티브 로우 입력을 받고 보수 출력을 제공한다.

  보수 출력이라는 말은 출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우라는 뜻이다.

<br/>

- **게이트가 있는 래치**

<br/>

- **플립플롭**

  논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다.

  이런 전이를 **에지**(**edge**) 라고 부른다.

  에지에 의해 데이터 변화가 촉발되는 래치를 **플립플롭**(**flip-flop**)이라고 부른다.

  S-R래치를 잘 연결하면 **양의 에지에 의해 변화가 촉발되는** positive edge-triggerd 플립플롭을 만들 수 있고, 이를 **D 플립플롭** 이라고 부른다.

  반대로 **음의 에지에 의해 변화가 촉발되는** 플립플롭은 논리 수준이 1에서 0으로 바뀔 때 작동한다.

<br/>

- **카운터**

  플립플롭을 응용한 회로 중에는 1, 2, 3 순서대로 수를 세는 **카운터**가 있다.

  **리플 카운터**(**ripple counter**) 라고 부르는 이유는 물에서 물결이 퍼져나가듯이 개수를 센 결과가 왼쪽에서 오른쪽으로 퍼져나가기 떄문이다.

  각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에 이 회로를 **비동기 카운터** 라고도 부른다.

  비동기 시스템은 언제 결과를 살펴봐야 맞는지 알기 어렵다는 단점이 있다.

  **동기적 카운터** 를 설계해서 리플 카운터의 타이밍 문제도 해결할 수 있다.

  리플 카운터와 달리 동기적 카운터는 상태 변경이 동시에 일어난다.

  이 말은 모든 플립플롭에 같은 클록을 병렬로 연결한다는 사실을 암시한다.

  대부분의 카운터에는 카운터를 0으로 되돌리는 CLR 입력이 있다.

  대부분의 카운터는 카운터를 활성화하는 EN 입력도 제공한다.

  U/D바 입력은 개수를 증가시킬지 감소시킬지를 결정한다.

  일부 카운터는 데이터 입력 D_0-n 과 카운터를 데이터 입력에 지정한 값으로 설정하기 위한 LD 신호 입력을 제공하기도 한다.

  카운터를 사용하면 시간을 셀 수 있다.

<br/>

- **레지스터**

  값을 기억하기 위해 D 플립플롭을 사용하는 것은 아주 흔한 응용이기 때문에 **레지스터** (**register**) 라는 회로를 쉽게 구할 수 있다.

  레지스터는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.

  가산기 출력을 클록을 사용해 레지스터에 넣고 나면, 가산기의 입력을 바꿔도 결과는 바뀌지 않는다.

  레지스터도 카운터에서 봤던 것과 비슷한 enable 입력을 제공하는 경우가 자주 있다는 사실도 알아두자.

<br/>

### 메모리 조직과 주소 지정

훨씬 더 많은 정보를 저장해야 한다면 어떻게 해야 할까?

레지스터를 많이 쌓아두는 것부터 시작할 수 있다.

하지만 새로운 문제가 생긴다. 어떤 레지스터를 사용해야 하는지 어떻게 지정할 수 있을까?

각 레지스터에 번호를 부여하는 것이다.

이 번호를 **주소**라고 한다

지정한 주소에 해당하는 레지스터의 출력을 선택할 방법이 필요하다.

실렉터는 우리 필요에 딱 들어맞는다.

시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있다.

이런 경우 **트라이스테이트** 출력이라는 또 다른 기본 요소가 필요하다.

메모리 컴포넌트는 연결지점이 아주 많다.

하드웨어 설계자는 이런 요소를 고민해야 한다.

(그래서 하드웨어 설계자들은) 메모리를 동시에 읽고 쓸 필요가 있는 경우는 거의 없다는 사실을 활용해 연결을 줄였다.

입력과 출력 데이터 연결을 합치고 read/write바 제어 신호를 사용하면 연결을 많이 줄일 수 있다.

enable 제어 신호는 메모리 전체를 켜거나 꺼서 여러 메모리 칩을 함께 연결할 수 있게 해준다.

주소와 데이터에는 개별 신호 대신 큰 화살표를 사용하는 것을 볼 수 있다.

이런 식으로 연관된 신호를 버스라고 부른다.

따라서 메모리 칩에는 주소 버스와 데이터 버스가 있다.

버스는 비트를 이동시키는 대량 교통 수단이다.

메모리 칩을 패키지에 넣을 때 해결해야 하는 다른 문제는 메모리 크기가 늘어나면 주소로 연결해야 할 비트 수도 많아진다는 점이다.

주소를 행과 열의 두 덩어리로 나눈다.

행과 열 주소를 **멀티플렉싱** 하면 주소 라인의 수를 반으로 줄일 수 있다.

이런 식의 절약을 위해 추가로 필요한 것은 멀티플렉싱한 주소를 저장하기 위한 레지스터뿐이다.

<br/>

- **임의 접근 메모리**

  메모리를 **임의 접근 메모리** (**RAM 램**) 이라고 부른다.

  RAM을 사용하면 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다.

  정적 RAM, 즉 SRAM은 비싸지만 아주 빠르다.

  동적 RAM, 즉 DRAM은 더 교묘한 방법을 사용한다.

  **커패시터** 라는 아주 작은 버킷 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다.

  문제는 이 버킷이 새기 때문에 가끔 메모리를 **갱신**해야 한다는 점이다.

  즉, 버킷에 주기적으로 전자를 다시 채워 넣어야 한다는 말이다.

  (이미 비트가 들어 있는) 버킷에 전자를 채우는 시점과 버킷에 정보를 쓰는 시간이 서로 겹치지 않게 조심해야 한다.

  DRAM은 집적도(밀도, 단위 면적당 비트 개수)가 높기 떄문에 큰 메모리 칩에 사용된다.

  큰 메모리 칩이라는 말은 주소가 더 많다는 뜻이고, 주소 멀티플렉싱 방식을 사용해야 한다는 뜻이다.

  행 주소 스트로브를 사용해 행 주소를 저장하는 속도가 열 주소 스트로브로 열 주소를 변경하는 것보다 더 빠르다.

  행을 **페이지**라고 부르기도 한다.

  SRAM이나 DRAM은 모두 **휘발성** 메모리다.

  **코어** 메모리는 오래된 **비휘발성** RAM으로 비트를 토러스 모양의 쇳조각에 저장한다.

  토러스는 도넛 바깥쪽의 전자기 간섭에 대한 저항력이 아주 크다는 멋진 물리적 특성이 있다.

  코어를 읽기 위한 세 번째 선인 **감지** 선이 있다.

  코어에 담긴 정보를 읽는 유일한 방법은 코어의 자화 상태를 바꾸려고 시도하고 어떤 일이 벌어지는지 감지하는 방법뿐이기 때문에 감지 선이 필요하다.

  실제로 코어 메모리는 평면을 모아 브릭을 만들기 때문에 3차원 메모리였다.

<br>

- **읽기 전용 메모리**

  **읽기 전용 메모리**, 즉 **ROM**이라는 이름은 그리 정호가한 이름이 아니다.

  실제로 ROM이라는 좋지 못한 이름 대신, 한 번만 쓸 수 있는 메모리라고 불러야 할 것이다.

  가장 초기 형태의 ROM은 홀러리스 카드일 것이다.

  나중에 이 카드는 IBM 카드로 알려진다.

  천공 종이 테이프는 ROM 기술과 관련이 있다.

  종이 테이프 롤에 뚤린 구멍은 비트를 표현한다.

  한 묶은을 떨어뜨리면 순서가 뒤섞여서 데이터가 꼬이는 카드에 비해 테이프는 그런 염려가 없다는 장점이 있다.

  반면 테이프가 찢어지면 수리를 하기 힘들다.

  아폴로호 비행 제어 컴퓨터에는 **코어 로프 메모리** 라는 다른 종류의 ROM이 사용됐다.

  바느질을 통해서만 비트를 기록할 수 있었기 때문에 코어 로프 메모리는 전자기 간섭의 영향을 받지 않았다.

  IBM 카드와 종이 테이프는 **순차적** 메모리다.

  데이터를 일정한 순서로만 읽을 수 있다는 뜻이다.

  실제로는 장기적으로 저장해야 하는 데이터를 저장하는 경우에만 유용하다.

  데이터를 사용하려면 카드나 테이프에 있는 정보를 RAM으로 읽어 들여야 한다.

  **마스크 프로그래머블** ROM이 도입됐다.

  **마스크** 는 직접 회로 생산 과정에서 사용하는 공판화를 뜻한다.

  마스크 프로그래머블 ROM은 임의 접근이 가능하다(아무 주소나 원하는 대로 읽을 수 있음)

  **프로그래머블 읽기 전용 메모리**(**PROM**)가 만들어졌다.

  PROM은 여러분이 직접 프로그래밍할 수 있는 ROM이지만 단 한 번만 ROM에 프로그램을 적어 넣을 수 있다.

  PROM 다음으로 **지울 수 있는 읽기 전용 메모리**(**EPROM**)를 만들어냈다.

  패키지 위쪽에 수정 창이 있어서 특별한 자외선 빛 아래 EPROM을 넣어두면 저장된 내용을 지울 수 있었다.

  **전기로 지울 수 있는 읽기 전용 메모리**(**EEPROM**)가 등장

  EEPROM은 전기로 지울 수 있는 EPROM이다.

  하지만 EEPROM을 지우는 과정은 느리기 때문에 자주 할 만한 일은 아니다.

  EEPROM은 내부 데이터를 아무 순서로나 쓰고 읽을 수 있기 때문에 기술적으로 RAM이다.

  하지만 데이터를 쓰는 데 시간이 오래 걸리고 RAM보다 비싸기 때문에 ROM을 대신하는 목적으로 쓰인다.

<br/>
