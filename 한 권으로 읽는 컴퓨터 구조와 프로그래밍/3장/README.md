## 메모리와 디스크의 핵심: 순차 논리

_컴퓨터는 비트를 어떻게 기억하는가_

이번 장에서는 **순차 논리** 를 배운다.

순서는 '시간적으로 어떤 값 뒤에 오는 다른 값'이라는 뜻이다.

조합 논리는 입력의 현재 상태만을 다룬다.

하지만 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.

<br/>

### 시간 표현과 상태

컴퓨터의 경우 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요하다.

<br/>

- **발진자**

  **되먹임**(피드백)

  인버터 출력은 다시 인터버 입력으로 들어가며, 이 입력은 다시 출력에 반영된다.

  이로 인해 출력이 0과 1 사이를 **진동한다 oscillate** .

  정확한 발진자를 적은 비용으로 효율적으로 만드는 방법은 크리스털을 활용하는 것이다.

  자석과 마찬가지로 크리스털도 전기와 관련이 있다.

  **전극**(**electrode** 즉, 전선)을 크리스털에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어낸다.

  그리고 전극에 전기를 가하면 크리스털이 구부러진다.

  이런 현상을 **피에조 전기(piezoelectric)** (또는 **압전**) 효과라고 부른다.

  크리스털 발진자는 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어낸다.

  입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.

  <br/>

- **클록**

  가산기의 지연 시간을 기다릴 수 있다.

  발진자는 컴퓨터의 **클록**(**clock**) (시간을 셀 주 있게 해주는 신호)을 제공한다.

  클록은 회로의 페이스를 결정한다.

  **비닝**(**binning**) (바구니에 넣는다는 뜻) 과정은 부품을 측정해서 그 특정에 따라 여러 다른 빈이나 무더기로 분류한다.

  컴퓨터를 **오버클로킹**(**overclocking**) 한다는 말

  이 말은 통계적으로 빈의 중간 정도에 위치하는 부폼을 부품이 고장 나지 않을 범위 안에서 클록을 빠르게 공급하는 도박을 한다는 뜻이다.

  <br/>

- **래치**

  하드웨어 기호 위에 선을 그으면 **반전** 을 뜻한다.

  때로 이를 액티브 하이에 반대되는 **액티브 로우** 라고 부른다.

  이렇게 위에 그은 선을 '바' 라고 읽는다.

  **S-R래치** S-R이라는 말은 set-reset (설정-재설정)을 뜻한다.

  이들은 액티브 로우 입력을 받고 보수 출력을 제공한다.

  보수 출력이라는 말은 출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우라는 뜻이다.

<br/>

- **게이트가 있는 래치**

<br/>

- **플립플롭**

  논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다.

  이런 전이를 **에지**(**edge**) 라고 부른다.

  에지에 의해 데이터 변화가 촉발되는 래치를 **플립플롭**(**flip-flop**)이라고 부른다.

  S-R래치를 잘 연결하면 **양의 에지에 의해 변화가 촉발되는** positive edge-triggerd 플립플롭을 만들 수 있고, 이를 **D 플립플롭** 이라고 부른다.

  반대로 **음의 에지에 의해 변화가 촉발되는** 플립플롭은 논리 수준이 1에서 0으로 바뀔 때 작동한다.

<br/>

- **카운터**

  플립플롭을 응용한 회로 중에는 1, 2, 3 순서대로 수를 세는 **카운터**가 있다.

  **리플 카운터**(**ripple counter**) 라고 부르는 이유는 물에서 물결이 퍼져나가듯이 개수를 센 결과가 왼쪽에서 오른쪽으로 퍼져나가기 떄문이다.

  각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에 이 회로를 **비동기 카운터** 라고도 부른다.

  비동기 시스템은 언제 결과를 살펴봐야 맞는지 알기 어렵다는 단점이 있다.

  **동기적 카운터** 를 설계해서 리플 카운터의 타이밍 문제도 해결할 수 있다.

  리플 카운터와 달리 동기적 카운터는 상태 변경이 동시에 일어난다.

  이 말은 모든 플립플롭에 같은 클록을 병렬로 연결한다는 사실을 암시한다.

  대부분의 카운터에는 카운터를 0으로 되돌리는 CLR 입력이 있다.

  대부분의 카운터는 카운터를 활성화하는 EN 입력도 제공한다.

  U/D바 입력은 개수를 증가시킬지 감소시킬지를 결정한다.

  일부 카운터는 데이터 입력 D_0-n 과 카운터를 데이터 입력에 지정한 값으로 설정하기 위한 LD 신호 입력을 제공하기도 한다.

  카운터를 사용하면 시간을 셀 수 있다.

<br/>

- **레지스터**

  값을 기억하기 위해 D 플립플롭을 사용하는 것은 아주 흔한 응용이기 때문에 **레지스터** (**register**) 라는 회로를 쉽게 구할 수 있다.

  레지스터는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.

  가산기 출력을 클록을 사용해 레지스터에 넣고 나면, 가산기의 입력을 바꿔도 결과는 바뀌지 않는다.

  레지스터도 카운터에서 봤던 것과 비슷한 enable 입력을 제공하는 경우가 자주 있다는 사실도 알아두자.

<br/>

### 메모리 조직과 주소 지정

훨씬 더 많은 정보를 저장해야 한다면 어떻게 해야 할까?

레지스터를 많이 쌓아두는 것부터 시작할 수 있다.

하지만 새로운 문제가 생긴다. 어떤 레지스터를 사용해야 하는지 어떻게 지정할 수 있을까?

각 레지스터에 번호를 부여하는 것이다.

이 번호를 **주소**라고 한다

지정한 주소에 해당하는 레지스터의 출력을 선택할 방법이 필요하다.

실렉터는 우리 필요에 딱 들어맞는다.

시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있다.

이런 경우 **트라이스테이트** 출력이라는 또 다른 기본 요소가 필요하다.

메모리 컴포넌트는 연결지점이 아주 많다.

하드웨어 설계자는 이런 요소를 고민해야 한다.

(그래서 하드웨어 설계자들은) 메모리를 동시에 읽고 쓸 필요가 있는 경우는 거의 없다는 사실을 활용해 연결을 줄였다.

입력과 출력 데이터 연결을 합치고 read/write바 제어 신호를 사용하면 연결을 많이 줄일 수 있다.

enable 제어 신호는 메모리 전체를 켜거나 꺼서 여러 메모리 칩을 함께 연결할 수 있게 해준다.

주소와 데이터에는 개별 신호 대신 큰 화살표를 사용하는 것을 볼 수 있다.

이런 식으로 연관된 신호를 버스라고 부른다.

따라서 메모리 칩에는 주소 버스와 데이터 버스가 있다.

버스는 비트를 이동시키는 대량 교통 수단이다.

메모리 칩을 패키지에 넣을 때 해결해야 하는 다른 문제는 메모리 크기가 늘어나면 주소로 연결해야 할 비트 수도 많아진다는 점이다.

주소를 행과 열의 두 덩어리로 나눈다.

행과 열 주소를 **멀티플렉싱** 하면 주소 라인의 수를 반으로 줄일 수 있다.

이런 식의 절약을 위해 추가로 필요한 것은 멀티플렉싱한 주소를 저장하기 위한 레지스터뿐이다.

<br/>
